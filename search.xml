<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>My LaTeX Cookbook</title>
      <link href="/2019/02/24/LaTeX-Cookbook/"/>
      <url>/2019/02/24/LaTeX-Cookbook/</url>
      
        <content type="html"><![CDATA[<p>整理目前有用到过的 LaTeX 常用命令，以便于查找。曾经是放在 Evernote 里面的，可惜它对于代码块复制黏贴后的格式支持实在有点差…</p><a id="more"></a><h2 id="表格">表格</h2><h3 id="修改表格行高">修改表格行高</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;array&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span></span><span class="tag">\<span class="name">arraystretch</span><span class="string">&#123;1.75&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="表格过长-需要延伸多页">表格过长，需要延伸多页</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;longtable&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% No \table environment on the outside</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;longtable&#125;</span><span class="string">[c]</span><span class="string">&#123;cccc&#125;</span></span></span><br><span class="line">1 &amp; 2 &amp; 3 &amp; 4 <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">5 &amp; 6 &amp; 7 &amp; 8 <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">caption</span><span class="string">&#123;&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">label</span><span class="string">&#123;&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;longtable&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% caption and label in the \longtable environment, with a "\\" at the end of the last line of the table body.</span></span><br></pre></td></tr></table></figure><p>注意 <code>longtable</code> 环境不支持 <code>\centerline{}</code>, 如果表格仍然过宽，可以使用以下方式横置页面。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;pdflscape&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;landscape&#125;</span></span></span><br><span class="line"><span class="comment">% TABLE</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;landscape&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="控制表格某一格宽度">控制表格某一格宽度</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;longtable&#125;</span><span class="string">[c]</span><span class="string">&#123;p&#123;35em&#125;</span></span>ccc&#125;</span><br></pre></td></tr></table></figure><p>尚未实验这种做法是否能用在 <code>tabular</code> 环境中，并且似乎这样控制大小之后，只能够左对齐。</p><h3 id="表格中文字过长-需要换行">表格中文字过长，需要换行</h3><p>在表格内部再加入一个 <code>tabular</code> 环境，此时的 <code>cols</code> 需要写成 <code>{@{}l@{}}</code>, 其中 <code>l</code> 可以换成 <code>c</code>, <code>r</code>.两个 <code>@{}</code> 的作用是消去不需要的空格。</p><p>例如</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|l|l|&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">        short 1 &amp; <span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;@&#123;&#125;</span></span>l@&#123;&#125;&#125; This is a very long text.<span class="tag">\<span class="name">\</span></span> You can split into several lines<span class="tag">\<span class="name">\</span></span> like this. <span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span> <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">        short 2 &amp; short 3 <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br></pre></td></tr></table></figure><p>效果为</p><p><img src="https://s2.ax1x.com/2019/10/30/Kf7mlt.png" alt="效果"></p><h2 id="图片">图片</h2><h3 id="多图片并列">多图片并列</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span><span class="string">[htb]</span></span></span><br><span class="line"><span class="tag">\<span class="name">centering</span></span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[t]</span><span class="string">&#123;0.32\textwidth&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">        <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">&#123;path1.png&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[t]</span><span class="string">&#123;0.32\textwidth&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">        <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">&#123;path2.png&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span></span><br><span class="line">     <span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[t]</span><span class="string">&#123;0.32\textwidth&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">centering</span></span></span><br><span class="line">        <span class="tag">\<span class="name">includegraphics</span><span class="string">[width=\textwidth]</span><span class="string">&#123;path3.png&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">caption</span><span class="string">&#123;Mutual Caption&#125;</span></span> <span class="comment">% If put inside minipage, then its independent caption for each figure</span></span><br><span class="line">    <span class="tag">\<span class="name">label</span><span class="string">&#123;&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意以上代码如果添加空行似乎会失效，无法并列而是回到上下排列。</p><h3 id="超大图片-tikz">超大图片 (tikz)</h3><p>对于超过一页 A4 大小的超大图片，需要在文档中间更改 <code>geometry</code> 才能放下，找了很多资料都没有成功。以下是一个暂时的解决方案：</p><p>新建一个 <code>.tex</code> 文件，利用 <code>\documentclass[border=1cm]{standalone}</code> 单独编译为一个 PDF 文件。</p><p>在主文件中，使用如下操作：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackege</span><span class="string">&#123;pdfpages&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% In the body where you want to place the picture</span></span><br><span class="line"><span class="tag">\<span class="name">includepdf</span><span class="string">[fitpaper=true]</span><span class="string">&#123;path/to/standalone.pdf&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="标题与-toc">标题与 TOC</h2><h3 id="中文">中文</h3><ul><li>调整中文文章标题格式</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">CTEXsetup</span><span class="string">[name = &#123;,、&#125;, number = &#123;\chinese&#123;section&#125;&#125;, format += &#123;\flushleft\heiti&#125;]</span><span class="string">&#123;section&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">CTEXsetup</span><span class="string">[number = &#123;(\chinese&#123;subsection&#125;)&#125;, format += &#123;\flushleft\normalfont\kaishu&#125;]</span><span class="string">&#123;subsection&#125;</span></span></span><br></pre></td></tr></table></figure><p>以上代码将格式调整如下：</p><p><img src="https://s2.ax1x.com/2019/02/25/k5l6oR.png" alt="示例"></p><p>这里 <code>\CTEXsetup</code> 的具体用法为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">CTEXsetup</span><span class="string">[OPTIONS]</span><span class="string">&#123;NAME&#125;</span></span></span><br></pre></td></tr></table></figure><p>NAME: <code>part</code>, <code>chapter</code>, <code>section</code>, <code>subsection</code>, etc.</p><p>OPTIONS:</p><ul><li><code>name</code>: 在章节编号前后插入指定的文本，用逗号分隔，即：<code>name={前,后}</code></li><li><code>number</code>: 章节编号的数字样式</li><li><code>format</code>: 标题的全局格式，包括字体大小、对齐方式等</li><li><code>nameformat</code>: 章节名（包含编号）的格式</li><li><code>numberformat</code>: 章节编号的格式（通常置空）</li><li><code>aftername</code>: 章节名和标题之间的格式变换【？？这啥</li><li><code>titleformat</code>: 标题内容的格式</li><li><code>beforeskip</code>: 标题与上方文本的间距</li><li><code>afterskip</code>: 标题与下方文本的间距</li><li><code>indent</code>: 标题的缩进距离</li></ul><p>通常而言中间几个 “format” 并不需要操作，通常控制的都还是整个整体，包括标题和章节名的格式。</p><p>设置其他中文标题名字：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">CTEXoptions</span><span class="string">[OPTIONS]</span></span></span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li><code>contentsname</code></li><li><code>listfigurename</code></li><li><code>listtablename</code></li><li><code>figurename</code></li><li><code>tablename</code></li><li><code>abstractname</code></li><li><code>indexname</code></li><li><code>bibname</code></li></ul><h3 id="general">General</h3><ul><li>插图与表格目录</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">listoffigures</span></span></span><br><span class="line"><span class="tag">\<span class="name">listoftables</span></span></span><br></pre></td></tr></table></figure><ul><li>将插图和表格目录包含在 <code>\tableofcontents</code> 中</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[nottoc]</span><span class="string">&#123;tocbibind&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="miscellaneous">Miscellaneous</h2><h3 id="中文字体与字号设置">中文字体与字号设置</h3><p>字体：</p><ul><li><code>\songti</code></li><li><code>\heiti</code></li><li><code>\fangsong</code></li><li><code>\kaishu</code></li><li><code>\lishu</code></li><li><code>\youyuan</code></li></ul><p>字号：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">zihao</span><span class="string">&#123;NUMBER&#125;</span></span></span><br></pre></td></tr></table></figure><p>NUMBER:</p><ul><li>‘0’: 初</li><li>‘1’-‘8’： 一至八</li><li>‘-’: 小</li></ul><p>示例：</p><ul><li>-0: 小初</li><li>4: 四号</li><li>-6: 小六</li></ul><h3 id="使用罗马字母">使用罗马字母</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">makeatletter</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\rmnum&#125;</span><span class="string">[1]</span><span class="string">&#123;\romannumeral #1&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\Rmnum&#125;</span><span class="string">[1]</span><span class="string">&#123;\expandafter\@slowromancap\romannumeral #1@&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">makeatother</span></span></span><br></pre></td></tr></table></figure><h3 id="多列-enumerate-itemize-列表">多列 <code>enumerate</code>/<code>itemize</code> 列表</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;multicol&#125;</span></span> <span class="comment">%多列enumerate列表</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;multicols&#125;</span><span class="string">&#123;2&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> a</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> b</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> c</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> d</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> e</span><br><span class="line">    <span class="tag">\<span class="name">item</span></span> f</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;multicols&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="将正文中未-cite-的文献添加到文末-reference-中">将正文中未 <code>\cite{}</code> 的文献添加到文末 Reference 中</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">nocite</span><span class="string">&#123;KEY&#125;</span></span></span><br></pre></td></tr></table></figure><p><code>KEY</code> 为 ‘<code>*</code>’ 时代表加入所有 BibTeX 文件中的条目</p><h3 id="用方框将部分内容框起进行强调">用方框将部分内容框起进行强调</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;framed&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\properframed&#125;</span><span class="string">[1]</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">        \centering</span></span></span><br><span class="line"><span class="tag"><span class="string">        \vspace&#123;-2 ex&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">begin</span><span class="string">&#123;framed&#125;</span></span></span><br><span class="line">            <span class="tag">\<span class="name">vspace</span><span class="string">&#123;-1.5 ex&#125;</span></span></span><br><span class="line">            #1</span><br><span class="line">            <span class="tag">\<span class="name">vspace</span><span class="string">&#123;-1.5 ex&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">end</span><span class="string">&#123;framed&#125;</span></span></span><br><span class="line">        <span class="tag">\<span class="name">vspace</span><span class="string">&#123;-2 ex&#125;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个新的命令方便框出较短内容进行强调，主要依赖的是 <code>framed</code> 宏包。</p><h3 id="代码排版">代码排版</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;minted&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usemintedstyle</span><span class="string">&#123;pastie&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\pyinline&#125;</span><span class="string">[1]</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">\mintinline&#123;python&#125;</span><span class="string">&#123;#1&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newenvironment</span><span class="string">&#123;py&#125;</span><span class="string">&#123;% Caution:</span></span></span><br><span class="line"><span class="tag"><span class="string">\vspace&#123;-1ex&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">VerbatimEnvironment</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;minted&#125;</span><span class="string">[xleftmargin=1em,breaklines,linenos]</span><span class="string">&#123;python&#125;</span></span><span class="comment">% Do NOT delete these comment syntax</span></span><br><span class="line">&#125;<span class="comment">% Otherwise there will be error when compiling</span></span><br><span class="line">&#123;<span class="comment">%</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;minted&#125;</span></span><span class="comment">%</span></span><br><span class="line"><span class="tag">\<span class="name">vspace</span><span class="string">&#123;-1.5ex&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% When including source file</span></span><br><span class="line"><span class="tag">\<span class="name">inputminted</span><span class="string">[xleftmargin=1em,breaklines,linenos]</span><span class="string">&#123;python&#125;</span><span class="string">&#123;path/to/src.py&#125;</span></span></span><br></pre></td></tr></table></figure><p>基于 <code>minted</code> 宏包，进行了针对 Python 的外部封装，其他语言同理。</p><p>此时编译时需要添加 <code>--shell-escape</code> 选项，并且需要先安装 Python 并且 <code>pip install pygments</code>.</p><h3 id="调整部分区域字体">调整部分区域字体</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fontspec&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newfontfamily</span></span><span class="tag">\<span class="name">ARG</span><span class="string">&#123;FONTNAME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">Main font text.</span><br><span class="line"></span><br><span class="line">&#123;<span class="tag">\<span class="name">ARG</span></span></span><br><span class="line">Text in FONTNAME font.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main font text.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="英文文章所有段落不缩进并通过隔行分段">英文文章所有段落不缩进并通过隔行分段</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;parskip&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="自定义计数器设置">自定义计数器设置</h3><p>新建一个计数器</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcounter</span><span class="string">&#123;COUNTER&#125;</span></span></span><br></pre></td></tr></table></figure><p>设置一个 <code>COUNTER-A</code>, 在 <code>COUNTER-B</code> 步进时自动清零（用例例如两层嵌套的列表，当外层列表计数器步进时，内部计数器也需要步进）</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">newcounter</span><span class="string">&#123;COUNTER-A&#125;</span><span class="string">[COUNTER-B]</span></span></span><br></pre></td></tr></table></figure><p>将计数器步进 1/任意数字</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">stepcounter</span><span class="string">&#123;COUNTNER&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">addtocounter</span><span class="string">&#123;COUNTER&#125;</span><span class="string">&#123;SOME-NUMBER&#125;</span></span></span><br></pre></td></tr></table></figure><p>直接给计数器设置一个数字</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">setcounter</span><span class="string">&#123;COUNTER&#125;</span><span class="string">&#123;SOME-NUMBER&#125;</span></span></span><br></pre></td></tr></table></figure><p>输出计数器的数字</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">arabic</span><span class="string">&#123;COUNTER&#125;</span></span></span><br></pre></td></tr></table></figure><p>以上命令会输出数字格式的计数器数字。还有其他命令可以选择：</p><ul><li><code>\alph</code>: a, b, c…</li><li><code>\Alph</code>: A, B, C…</li><li><code>\roman</code>: 小写罗马数字</li><li><code>\Roman</code>: 大写罗马数字</li></ul><h3 id="波浪号与反斜杠打法">波浪号与反斜杠打法</h3><ul><li>波浪号：<code>\textasciitilde</code></li><li>反斜杠：<code>\textbackslash</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概统 &amp; 公司金融 Cheat Sheet</title>
      <link href="/2019/01/11/CheatSheet-share/"/>
      <url>/2019/01/11/CheatSheet-share/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="/files/Statistics_cheat_sheet.tex" download="Statistics_cheat_sheet.tex">概统下载</a>   <a href="/files/CF_cheat_sheet.tex" download="CF_cheat_sheet.tex">公金下载</a></strong></p><p><small>讲真这学期花时间最多的不是学内容而是这两张 cheat sheet 【逃x </small></p><a id="more"></a><p>提供 tex 代码方便修改。两门课都不分期中和期末，直接放上了所有的内容，可以用 verbatim 宏包提供的 comment 环境去掉不需要的部分。毕竟估计每年进度安排不一样，各取所需。</p><p>我的编译环境：<font face="Times New Roman"> XeTeX 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) </font></p><ul><li><a href="#gaitong">概统 Readme</a></li><li><a href="#gongjin">公金 Readme</a></li></ul><hr><h2 id="update-2019-1-14-有关字体设置">Update 2019-1-14 有关字体设置</h2><p>在概统考试前一天的时候，就感觉到默认的 Times New Roman 字体在这么密集的情况下阅读体验极差，因此也试验了几种字体，但是效果都无法令人满意。</p><p>今天逛知乎的时候发现了 <a href="https://github.com/georgd/EB-Garamond/blob/master/specimen/Specimen.pdf" target="_blank" rel="noopener"> EB Garamond </a> 这个超美的字体，尝试应用了之后发现效果<strong>极好</strong>，阅读体验大大提升，已经更新在两份 tex 文件中。</p><p>但是由于字体宽度不同等原因，有可能对页面布局造成影响。可以手动对代码进一步进行调整，也可以禁用此字体，使用 Times New Roman. 如需禁用，只需要 comment 掉导言区的这一行代码即可：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[lining]</span><span class="string">&#123;ebgaramond&#125;</span></span></span><br></pre></td></tr></table></figure><p>后文中的预览图更新有些麻烦，就暂时保留了，查看新字体效果直接编译即可。</p><p><span id="gaitong"><span></span></span></p><hr><h2 id="readme-for-概统-cheatsheet">Readme for 概统 CheatSheet</h2><blockquote><p>For 经管学院黎波老师概率论与数理统计课程。</p></blockquote><ul><li>Feature:</li></ul><ol><li>没有使用任何一张截图。直接编译渲染可以绝对保证打印的清晰度和排版整齐。</li><li>Syntax Highlighting for R code.</li><li>根据自己的使用习惯简单封装了一些命令，以方便修改：【因为对 LaTeX 没怎么研究所以代码很丑【逃</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">sectionline</span></span>    <span class="comment">% 一条横线</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">bigtitle</span><span class="string">&#123;title&#125;</span></span>    <span class="comment">% 大标题          % 调整 \section, \subsection 等 built-in 标题的字体大小、行距和格式等过于繁琐</span></span><br><span class="line"><span class="tag">\<span class="name">smalltitle</span><span class="string">&#123;title&#125;</span></span>  <span class="comment">% 小标题        % 这里的操作是直接 \noindent\textbf&#123;&#125;, 或者 \noindent\textbf&#123;\textit&#123;&#125;&#125;, 参见源码</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">rcode</span><span class="string">&#123;some-code&#125;</span></span>      <span class="comment">% 行内 R 语言代码</span></span><br><span class="line"><span class="tag">\<span class="name">properframed</span><span class="string">&#123;emphasized part&#125;</span></span>       <span class="comment">% 框起来需要强调的部分</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;rcodeblock&#125;</span></span>      <span class="comment">% 多行 R 语言代码</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;rcodeblock&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">minitabOut</span><span class="string">&#123;output-Table&#125;</span></span>  <span class="comment">% 修改字体为 Courier New, 与教材上的 MINITAB 输出示例一致</span></span><br></pre></td></tr></table></figure><ul><li>使用 minted 宏包做 R 语言 highlighting，需要的步骤如下。如果不需要 R 语言部分，以下可以忽略。</li></ul><ol><li><strong>Dependency: Python 3</strong></li><li>安装 Pygments</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pygments</span><br></pre></td></tr></table></figure><ol start="3"><li>LaTeX的编译命令需要添加 <em>“--shell-escape”</em></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex.exe -synctex=1 -interaction=nonstopmode --shell-escape Statistics_cheat_sheet.tex</span><br></pre></td></tr></table></figure><ul><li>用 <font face="Courier New">Courier New</font> 字体（与教材一致）查看对 MiniTab 输出的解释，必须使用 XeLaTeX 或 LuaLaTeX 编译，局部修改字体使用的 fontspec 宏包不支持 pdfLaTeX. 另外需要保证电脑中安装了 Courier New 字体。</li><li>为了保证文字的紧凑，作了很多 ad-hoc 的调整，可能直接对整体代码编译会有部分表格或公式呈现效果不好，需要在删选出期中/期末需要的内容后简单调整。</li><li>最后，存在一个小缺陷是在后面章节出现了 <img src="https://i.postimg.cc/3rjVKr8M/xi.png" width="40" height="40"> 这种蛋疼符号【没错那个点是符号的一部分x】之后，由于 Mathpix 识别经常失败，很多点都是手动加的，位置和格式有时候不同。当然几乎完全不影响阅读和使用。</li></ul><p>以下是预览：</p><img src="https://s2.ax1x.com/2019/01/10/FOjn3T.png"><p><span id="gongjin"></span></p><hr><h2 id="readme-for-公金-cheatsheet">Readme for 公金 CheatSheet</h2><blockquote><p>For 经管学院陈云玲老师公司金融课程。</p></blockquote><p>一些必要的说明：</p><ol><li><strong>需要用到一张 Dupont Analysis 的截图</strong>，实在是懒得写 tikz 的代码了【】。可以找一张想放的杜邦分析的图命名为 “dupont.png”, 放在同一目录下再编译。也可以直接修改代码，位置在第 180 行左右。</li><li>同样支持概统 cheat sheet 中的 <code>\sectionline</code>, <code>\bigtitle</code>, <code>\smalltitle</code> 三个命令。</li><li>因为需要记在纸上的东西比较少，所以还写了很多复习过程中遇见的要提醒自己的东西，这部分可以直接删去。</li></ol><p>以下是预览：</p><img src="https://s2.ax1x.com/2019/01/10/FOjmCV.png">]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构整理 - 详细内容</title>
      <link href="/2019/01/05/DSA-summary-detail/"/>
      <url>/2019/01/05/DSA-summary-detail/</url>
      
        <content type="html"><![CDATA[<p>请先阅读<a href="/2019/01/05/DSA-summary/">说明</a>。</p><a id="more"></a><h1>Basis of Algorithm Analysis</h1><h2 id="rules-of-o-n-syntax">Rules of O(n) Syntax</h2><ol><li>Definition: $T(N) = O(f(N))$ if there are positive constants $c$ and $n_0$ such that $T(N) \leq c\times f(N)$ when $N \geq n_0$. Use the tightest one in the course. e.g. $2N^2 = O(N^2)$<br></li><li>If $T_1(N) = O(f(N))$ and $T_2(N) = O(g(N))$, then<ol><li>$T_1(N) + T_2(N) = \max(O(f(N)),O(g(N)))$</li><li>$T_1(N) \times T_2(N) = O(f(N)\times g(N))$<br></li></ol></li><li>如果 $T(N)$ 是 k 阶多项式, $T(N) = O(N^k)$<br></li><li>$\log^k(N) = O(N)$ for any constant $k$.</li></ol><p>以下复杂度依次递增：</p><p>$2/N &lt; 1 &lt; N^{1/2} &lt; N &lt; N\log(\log(N)) &lt; N\log(N)$</p><p>$= N\log(N^2) &lt; N\log^2N &lt; N^{1.5} &lt; N^2 &lt; N^2\log(N) &lt; N^3 &lt; 2^{N/2} &lt; 2^N$</p><h2 id="general-rules-for-algorithm-analysis">General Rules for Algorithm Analysis</h2><ol><li>For loops: Number of statements $\times$ number of iterations</li><li>Nested loops: Number of statements $\times$ loop1 $\times$ loop2 …</li><li>Consecutive statements: Add them all.</li><li>If/else statement: $\max(\text{if statement, else statement})$</li></ol><p>如果有函数调用，先计算被调用函数的复杂度。</p><h1>Primary Examples of Algorithm</h1><h2 id="fibonacci-sequence">Fibonacci Sequence</h2><p>递归法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FIB</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FIB(n<span class="number">-1</span>)+FIB(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FIB</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev1 = <span class="number">1</span>, prev2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">2</span>, temp;</span><br><span class="line">    <span class="keyword">while</span>(curr &lt; n)&#123;</span><br><span class="line">        temp = prev1 + prev2;</span><br><span class="line">        prev1 = prev2;</span><br><span class="line">        prev2 = temp;</span><br><span class="line">        curr ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法数列形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">FIB_arr_loop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Fib_arr[<span class="number">1000</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        Fib_arr[i] = Fib_arr[i<span class="number">-1</span>] + Fib[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fib_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maximum-subsequence-sum-problem">Maximum Subsequence Sum Problem</h2><h3 id="exhaustive-strategy">Exhaustive Strategy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="comment">// Sum a[i] to a[j] and update max;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="optimized-exhaustive-strategy">Optimized Exhaustive Strategy</h3><p>穷举法中，可以有 $\sum \limits_{k=i}^j a[k] = \sum \limits_{k=i}^{j-1} a[k] + a[j]$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> this_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">        this_sum += a[j];</span><br><span class="line">        max = max &gt; this_sum ? max : this_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="divide-and-conquer">Divide-and-Conquer</h3><p>思路：最大子串和只存在三种可能</p><ol><li>只存在于左边一半中</li><li>只存在于右边一半中</li><li>它穿过了中间，存在于左右两半中</li></ol><p>解决方案：</p><ol><li>Base case: 左半/右半只有 1 个或 0 个元素。</li><li>对于任何 N &gt; 1 元素的序列，将其划分为两半。</li><li>计算左半/右半的最大和，和跨过中间的子串的最大和。<ul><li>跨过中间的子串的最大和算法：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LeftBorderSum = <span class="number">0</span>, RightBorderSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> MaxLeftBorderSum, MAXRightBorderSum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = center; i &gt;= left; i--)&#123;</span><br><span class="line">    LeftBorderSum += A[i];</span><br><span class="line">    <span class="comment">// Update MaxLeftBorderSum</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = center; i &lt;= left; i++)&#123;</span><br><span class="line">    RightBorderSum += A[i];</span><br><span class="line">    <span class="comment">// Update MaxRightBorderSum</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MaxLeftBorderSum + MaxRightBorderSum;</span><br></pre></td></tr></table></figure><ol start="4"><li>在以上三种情况中选择最大的，就是此串的最大子串和。</li></ol><h3 id="the-best-algorithm">The Best Algorithm</h3><p>思路：如果一个子串的和 &lt; 0，那它一定不是最后的最大子串和的前缀。因此只需要扫描一遍数组，如果某一段的和为负数，就直接将其忽略，从下一个元素开始计算。（同时更新全局最大子串和）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> this_sum = <span class="number">0</span>, max_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, best_i = <span class="number">0</span>, best_j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">    this_sum += a[j];</span><br><span class="line">    <span class="keyword">if</span>(this_sum &gt; max_sum)&#123;</span><br><span class="line">        max_sum = this_sum;</span><br><span class="line">        best_i = i;</span><br><span class="line">        best_j = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(this_sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">        this_sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_sum;</span><br></pre></td></tr></table></figure><h2 id="binary-search">Binary Search</h2><p>适用于已经排序的数组。</p><ol><li>比较数组中间元素与目标的大小</li><li>如果中间元素较大，就在左子串中寻找；如果中间元素较小，就在右子串中寻找。（假设升序，降序亦然）</li></ol><h1>Abstract Data Type (ADT)</h1><h2 id="list">List</h2><h3 id="array-implementation">Array Implementation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">&#125; Array_List[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>优势：</p><ul><li>易于理解</li><li>易于实现</li><li>易于随机访问<ul><li>访问任意元素复杂度 O(1)</li><li>更新任意元素复杂度 O(1)</li></ul></li></ul><p>劣势：</p><ul><li>浪费空间</li><li>难以重新组织元素<ul><li>插入元素复杂度 O(n)</li><li>删除元素复杂度 O(n)</li></ul></li></ul><h3 id="linked-list">Linked List</h3><p>优势：</p><ul><li>易于更新元素（插入/删除）</li><li>不需要提前分配空间</li></ul><p>劣势：</p><ul><li>难以实现</li><li>无法实现随机访问</li><li>需要额外的空间分配给指针</li></ul><h3 id="doubly-linked-list">Doubly Linked List</h3><p>在链表的基础上为每一个节点增加一个指向前序节点的指针。</p><p>Costs:</p><ul><li>增加了空间需求</li><li>增加了插入和删除时需要处理的指针数量</li></ul><p>Benefits:</p><ul><li>将删除元素的时间复杂度降为 O(1)</li><li>简化反向遍历</li></ul><h3 id="circularly-linked-list">Circularly Linked List</h3><p>将链表首尾相连。</p><h2 id="stack">Stack</h2><p>Definition: a list with the restriction that insertions and deletions can be performed only at the top. The base of a stack is not allowed to operate directly.</p><p>LIFO, last in first out.</p><p>Fundamental operations:</p><ul><li>Top: get the value of the top cell</li><li>Push: insert on the top</li><li>Pop: delete the top</li></ul><h3 id="linked-list-implementation">Linked List Implementation</h3><p>基础的链表实现，将 header 所指的对象认为是 top，所有的操作只能够对 header 所指向的 node 进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asserting s is not empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x, Stack s)</span></span>&#123;</span><br><span class="line">    PtrToNode tmp;</span><br><span class="line">    <span class="comment">// malloc space for tmp and fill in the element x</span></span><br><span class="line">    tmp-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    PtrToNode first = s-&gt;next;</span><br><span class="line">    s-&gt;next = s-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，置空 Stack 是通过反复调用 Pop 完成的。</p><h3 id="array-implementation-v2">Array Implementation</h3><p>实现方法：</p><ol><li>声明一个数组 stack[MaxSize]</li><li>声明 int TopOfStack 作为 cursor</li><li>TopOfStack == -1 表示堆栈是空的</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackRecord</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> * <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackRecord</span> * <span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Asserting s is neither full nor empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;<span class="built_in">array</span>[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x, Stack s)</span></span>&#123;</span><br><span class="line">    s-&gt;top ++;</span><br><span class="line">    s-&gt;<span class="built_in">array</span>[s-&gt;top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack s)</span></span>&#123;</span><br><span class="line">    s-&gt;top --;  <span class="comment">// No need to clean the top cell.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，置空 Stack 只需要直接将 s-&gt;top = -1, 无需对数组进行任何操作。</p><h3 id="application-maze-solving">Application: Maze Solving</h3><p>解决方案：</p><ol><li>访问(1,1)，即 Push(1,1).</li><li>对于访问到的每个位置，如果它就是出口，那么问题解决。如果不是，那就依次尝试访问上下左右四个紧邻的位置。</li><li>如果被尝试访问的紧邻位置 P 满足以下两个条件就 Push§，否则跳过<ol><li>不是墙</li><li>（全局）从未被访问过</li></ol></li><li>如果当前 Stack 顶部的位置 Q 的四个方向都被尝试过无法访问，那就 Pop(Q)，并尝试访问 Pop 后 Stack 顶部的位置的下一个方向。</li><li>如果 Stack 最终为空，则没有可行路径。</li></ol><h2 id="queue">Queue</h2><p>Fundamental operations:</p><ul><li>Enqueue: inserts an element at the rear of the list.</li><li>Dequeue: deletes (and returns) the element at the front of the list.</li></ul><p>FIFO, first in first out.</p><h3 id="circular-array-implementation">Circular Array Implementation</h3><p>实现方法：</p><ol><li>声明一个数组 queue[MaxSize]</li><li>声明 int front, rear, size 来记录信息</li><li>将数组在逻辑上首尾相连</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueRecord</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> * <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueRecord</span> * <span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Asserting q is neither full nor empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Succ</span><span class="params">(<span class="keyword">int</span> position, Queue q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++position == q-&gt;capacity)&#123;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">int</span> x, Queue q)</span></span>&#123;</span><br><span class="line">    q-&gt;size++;</span><br><span class="line">    q-&gt;rear = Succ(q-&gt;rear,q);</span><br><span class="line">    q-&gt;<span class="built_in">array</span>[q-&gt;rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dequeue</span><span class="params">(Queue q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = Front(q);</span><br><span class="line">    q-&gt;size--;</span><br><span class="line">    q-&gt;front = Succ(q-&gt;front,q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="application-maze-solving-floodfill-algorithm">Application: Maze Solving - FloodFill Algorithm</h3><p>洪水算法的本质是一个树形结构，通过逐步向外遍历迷宫的方式，使得存储信息的树上第 i 层上有所有第 i 步可以到达的节点。这个算法能够找到迷宫的最短路径。</p><p>利用 Queue 来实现树的遍历与保存。</p><p>Queue 中每个 cell 保存的信息：</p><ul><li>index: 这个 cell 在整个队列中的序号</li><li>position: cell 中位置的坐标</li><li>pre: 到达这个位置的前一步位置的 cell 所在队列中的序号</li></ul><p>注意此时的队列不是循环的，大小是 $m\times n$，Dequeue 之后不清除前面的信息，最后检索整个路径时需要回溯。</p><p>解决方案：</p><ol><li>Enqueue 起点</li><li>Dequeue 并且获得 Front，记为 P. 测试它可以走的各个方向上的位置，如果这个位置 Q 既没有被访问过，也不是墙，就 Enqueue(Q)，注意记录此时的 pre 为 P 的 index</li><li>反复 2 直到：<ol><li>找到终点，通过不断跟踪 pre 找到整条路径</li><li>队列为空时仍然没有找到终点，则没有任何可能的路径</li></ol></li></ol><h2 id="binary-trees">Binary Trees</h2><p>Definition: a tree in which a node can have 0, 1 or 2 children.</p><p>二叉树的深度：</p><ul><li>Worst case: $N - 1$</li><li>Best case: $O(\log(N))$</li><li>Average case: $O(\log(N))$ ~ $O(N^{1/2})$</li></ul><p>Implementation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    Tree left;</span><br><span class="line">    Tree right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(Height(t-&gt;left),Height(t-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tree-traversal">Tree Traversal</h3><p>四种遍历树的方式：</p><ul><li>Inorder 中序遍历<ul><li>Left sub-tree → (Node) Data → Right sub-tree</li></ul></li><li>Postorder 后序遍历<ul><li>Left sub-tree → Right sub-tree → (Node) Data</li></ul></li><li>Preorder 后序遍历<ul><li>(Node) Data → Left  sub-tree → Right sub-tree</li></ul></li><li>Level-order 层次遍历<ul><li>广度优先，先遍历所有 D 深度的节点，再遍历 D + 1 深度的节点</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Tree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Inorder(t-&gt;left);</span><br><span class="line">        Visit(t-&gt;element);</span><br><span class="line">        Inorder(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postorder and Preorder are similar.</p><p>层次遍历需要使用一个队列来完成。</p><p>解决方案：</p><ol><li>声明一个和节点数同样大小的 Queue, 以及游标 rear, front</li><li>Enqueue 根节点</li><li>Dequeue 并且获取 front, 访问 front 的元素，并且 Enqueue 此时 front 的所有子节点</li><li>反复进行 (3) 直到队列为空为止</li></ol><h3 id="threaded-binary-tree">Threaded Binary Tree</h3><p>想法：任意 N 个节点的树中都有 N+1 个空指针，将这些空指针指向其前驱或后继，以提高遍历的效率。需要创建额外的变量来表达某个指针是线索还是子节点。</p><p>以中序线索二叉树（需要做中序遍历的二叉树）为例：实现方法：</p><ul><li>如果节点没有左子节点，让其左指针指向其中序访问时的前驱</li><li>如果节点没有右子节点，让其右指针指向其中序访问时的后继</li></ul><p>例如对于下左二叉树，中序遍历的顺序为 B → D → C → A → E, 因此将其线索化为下右图<img src="https://s2.ax1x.com/2019/01/04/FTCMnA.png" width="300">    <img src="https://s2.ax1x.com/2019/01/04/FTCUXj.png" width="300"></p><p>进行中序线索化时，需要一个全局变量来记录全局的前驱后继，以修改节点的空指针。</p><h3 id="binary-search-tree">Binary Search Tree</h3><p>特性：</p><ul><li>每一个节点的值是不相同的。</li><li>每个节点左子树上所有节点的值都小于该节点。</li><li>每个节点右子树上所有节点的值都大于该节点。</li></ul><p>基本操作：</p><ul><li>MakeEmpty(): 采用后序遍历，free 每个节点</li><li>Find(): 类似二分查找</li><li>FindMin(): 找到整棵树最左侧的节点</li><li>FindMax(): 找到整棵树最右侧的节点</li><li>Insert(): 在树 t 中插入元素 x<ol><li>Find(x,t)</li><li>如果 x 被查找到，结束。（每个节点值不同，不能重复插入）</li><li>否则，将 x 插入到查找过程中遍历的最后一个节点的子节点，注意比较大小。</li></ol><ul><li>x 将永远被作为一个 leaf（没有后继节点）</li></ul></li><li><span id="normalDelete"></span>Delete(): 在树 t 中删除元素 x<ol><li>Find(x,t), 记为节点 P</li><li>如果 P 是一个 leaf，直接删除</li><li>如果 P 只有一个子节点 Q, 无论 Q 是左/右子节点，都直接将 P 的父节点指向 P 的指针指向 Q</li><li>如果 P 有两个子节点 M, N （分别为左，右）:<ol><li>将 P 上的元素<strong>替换</strong>为 N 和 N 的所有子节点中最小的元素 FindMin(N), 记为 O</li><li>删除 O，此时 O 必然没有左子节点，因此化归到 (2) 或者 (3) 的情况</li></ol></li></ol></li></ul><p>当所有节点都只有一个子节点（除了最后一个节点）时，实际上成为了 List, 各种操作的复杂度会上升为 $O(N)$</p><h2 id="avl-tree">AVL Tree</h2><p>Definition: A Binary Search Tree with restriction: For every node in the tree, the height of its left and right sub-trees can differ by at most 1.</p><ul><li>The height of an empty tree is -1.</li><li>The height of an one-node tree is 0.</li></ul><h3 id="insertion-and-rotation">Insertion and Rotation</h3><p>在 BST 的插入节点操作之后，可能会使 AVL Tree 不再平衡，这里就需要引入旋转操作来保持平衡。</p><p>某个节点 I (Imbalanced) 不满足平衡条件的四种情况：</p><ol><li>I 的左子节点 L 的左子树中插入了节点 X，&quot;/&quot;</li><li>I 的左子节点 L 的右子树中插入了节点 X，&quot;&lt;&quot;</li><li>I 的右子节点 R 的左子树中插入了节点 X，&quot;&gt;&quot;</li><li>I 的右子节点 R 的右子树中插入了节点 X，&quot;\&quot;</li></ol><p>注意虽然插入某个节点 X 这一操作的“瞬间”会影响从 X 到根节点的所有节点，改变其左右子树高度差，但调整是<strong>从下向上</strong>回溯的。从插入的节点向上更新高度和高度差，将第一个不平衡的节点记为 I, I 本身会先进行旋转调整保持自身平衡，此时其高度不变，因此其所有父节点的左右子树高度差不变，不会发生旋转。</p><p>另外，这里声明一个老师 PPT 上没有的“轴”的概念便于理解。它从图上看是每次旋转发生的轴，同时也是被调整的树完成调整后的根节点，记为 A(Axis).</p><h4 id="single-rotation">Single Rotation</h4><p>适用于 case 1 &amp; 4, 即&quot;/“和”\“的情况。这里仅以”/&quot;情况为例，另一侧为镜像。</p><p>这张图表示得非常清楚，5 对应 I, 3 对应 L, 1 插入的位置是在 3 的左子树。此时 A == L.</p><img src="https://s2.ax1x.com/2019/01/04/FTZzpq.png"><p>旋转时发生的事件：</p><ol><li><strong>I 的左指针指向 A 的右指针</strong></li><li>A 的右指针指向 I</li><li>【图中未显示】将原先 I 的父节点指向 I 的指针现在指向 A。<ul><li>例如上图中原先 5 可能是 7 的左子节点，那么在旋转完成后，7 的左指针指向 3，并且 7 和以上级别的节点不需要进行调整，因为现在以 3 为根节点的子树的深度和插入前没有变化</li><li>这个指针的说法很繁琐，可以用“<strong>返回 A</strong>”来代替。将事件看作：对于 I 的父节点 U(unaffected) 而言，其左子树(I)中发生的一切都是在黑箱中完成的，U 只需要接收黑箱输出的一个节点作为其左子节点即可，而“返回 A”就是这个黑箱输出 A.</li></ul></li></ol><p>另外，如果图中 2 和 4 不存在，即 3 的右节点是 NULL，1 直接是 3 的左节点，则以上描述的步骤仍然完全相同。</p><h4 id="double-rotation">Double Rotation</h4><p>适用于 case 2 &amp; 3, 即&quot;&lt;“和”&gt;“的情况。这里仅以”&lt;&quot;情况为例，另一侧为镜像。</p><p>仍然注意 50 对应 I, 40 对应 L, 47 插入的位置是在 L 的右子树。这里 A 是 L 的右子节点。</p><img src="https://s2.ax1x.com/2019/01/04/FTegg0.png"><p>旋转时发生的事件：</p><ol><li>对 A 进行向左的单旋转<ol><li>L 的右指针指向 A 的左子节点（这里是 NULL）</li><li>A 的左指针指向 L</li><li>返回 A</li></ol></li><li>对 A 再进行一次向右的单旋转<ol><li>I 的左指针指向 A 的右子节点</li><li>A 的右指针指向 I</li><li>返回 A</li></ol></li><li>最终返回 A</li></ol><p>双旋转就是两个方向的两次单旋转而已。</p><ul><li>case 2 - “左子节点右子树”，单旋转先向左再向右</li><li>case 3 - “右子节点左子树”，单旋转先向右再向左</li></ul><h3 id="deletion">Deletion</h3><p>这一部分在老师的 PPT 上完全没有提到，全部由自己的思考完成，可能有误。</p><p>实现方案：</p><ol><li>首先进行<a href="#normalDelete">正常的删除操作</a>。</li><li>从被删除的节点开始向上回溯检查是否存在不平衡，找到不平衡的节点。</li><li>对于该不平衡的节点 I ，其不平衡的原因有两种情况（以下记 L 为 I 的左子树，R 为 I 的右子树：<ol><li>类似于插入时四种情况：<ol><li>L 的高度比 R 的右子树少 1，即&quot;\&quot;</li><li>L 的高度比 R 的左子树少 1，即&quot;&gt;&quot;</li><li>R 的高度比 L 的右子树少 1，即&quot;&lt;&quot;</li><li>R 的高度比 L 的左子树少 1，即&quot;/&quot;</li></ol></li><li>其中一方的两个子节点具有同样的高度：<ol><li>L 的高度比 R 的两颗子树都少 1</li><li>R 的高度比 L 的两颗子树都少 1</li></ol></li></ol></li></ol><p>显然其中一半的状况是对称的，因此只讨论另一半状况。</p><p><em>【灵魂画手上线】</em><img src="https://s2.ax1x.com/2019/01/04/FT39js.png"></p><p>假设 L 在删除前存在一个子节点，此时 I 是平衡的，删除的对象是 L 的子节点，此后产生不平衡。对于第一种和第二种情况，分别直接按照插入时对于 “&gt;” 和 &quot;\&quot;的处理方法，进行 Double Rotate 和 Single Rotate 就可以完成。对于第三种情况，检验发现直接以 R 为轴进行 Single Rotate，可以直接恢复平衡。</p><img src="https://s2.ax1x.com/2019/01/04/FTG7jJ.png"><p>与插入不同的是，删除某一个节点引起的树的调整，可能让该树的高度减小，而并非如插入那样调整后能保证不变。因此一次删除可能会造成全局层面多颗子树的调整。</p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x, AvlTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Position tmp;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Start locating x</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;element) &#123;</span><br><span class="line">t-&gt;left = Delete(x, t-&gt;left);</span><br><span class="line">t-&gt;height = <span class="number">1</span> + MaxSubTreeHeight(t);    <span class="comment">// Remember to update the height.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;element) &#123;</span><br><span class="line">t-&gt;right = Delete(x, t-&gt;right);</span><br><span class="line">t-&gt;height = <span class="number">1</span> + MaxSubTreeHeight(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Finish locating t, now t-&gt;element == x</span></span><br><span class="line">    <span class="comment">// Start processing the standard deleting procedure.</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;left &amp;&amp; t-&gt;right) &#123;  <span class="comment">// Case when the element to be deleted has two nodes.</span></span><br><span class="line">tmp = FindMin(t-&gt;right);</span><br><span class="line">t-&gt;element = tmp-&gt;element;</span><br><span class="line">t-&gt;right = Delete(t-&gt;element, t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// Case when the element to be deleted has one node.</span></span><br><span class="line">tmp = t;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Finish standard deleting procedure.</span></span><br><span class="line">    <span class="comment">// Start adjusting.</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span> &amp;&amp; IntervalBetweenSubHeight(t) == <span class="number">2</span>) &#123;    <span class="comment">// If t is unbalanced</span></span><br><span class="line"><span class="keyword">if</span> (Height(t-&gt;left) &gt; Height(t-&gt;right)) &#123;   <span class="comment">// If L is deeper than R, resembling "/" or "&lt;" in insertion case.</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;left-&gt;right != <span class="literal">NULL</span>) &#123;  <span class="comment">// Case "&lt;"</span></span><br><span class="line">t = DoubleRotateWithLeft(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// Case "/"</span></span><br><span class="line">t = SingleRotateWithLeft(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// If R is deeper than L, resembling "\" or "&gt;" in insertion case.</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;right-&gt;right == <span class="literal">NULL</span> &amp;&amp; t-&gt;right-&gt;left != <span class="literal">NULL</span>) &#123;    <span class="comment">// Case "&gt;"</span></span><br><span class="line">t = DoubleRotateWithRight(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// Case "\"</span></span><br><span class="line">t = SingleRotateWithRight(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t-&gt;height = <span class="number">1</span> + MaxSubTreeHeight(t);    <span class="comment">// Updating height.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Sorting</h1><p>对于 N 个元素进行排序，这些元素当前存储在大小为 N 的数列内部。</p><ul><li>Internal Sorting （内部排序）：数据量较小，可以直接读取到内存中进行处理</li><li>Expernal Sorting （外部排序）：数据量过大，无法直接读取到内存中，需要与外部存储进行 I/O</li></ul><blockquote><p>此部分的复杂度分析相对重要，见<a href="#appendix-table-of-complexity-of-all-algorithms">所有复杂度汇总表格</a></p></blockquote><h2 id="bst-based-sorting">BST-Based Sorting</h2><p>步骤：</p><ol><li>用数据构造一颗 BST</li><li>进行 Inorder 遍历并且输出</li></ol><h2 id="naive-strategy-straight-selection-sort">Naive Strategy - Straight Selection Sort</h2><p>步骤：</p><ol><li>扫描整个数列，找到最小元素</li><li>将其与数列的第一个元素进行交换</li><li>对数组的剩余部分重复以上步骤</li></ol><h2 id="insertion-sort">Insertion Sort</h2><ol><li>总共扫描 N - 1 次</li><li>对于第 $p$ 次扫描 ( $p \in [1,N-1]$ ), 将下标为 $p$ 的元素不断与其左侧元素比较，如果顺序错误就调换位置，直至到达合适的位置。</li><li>扫描完成后数列下标为 $[0,p]$ 的部分是有序的。</li></ol><h3 id="lower-bound-for-simple-sorting-algorithms">Lower Bound for Simple Sorting Algorithms</h3><p>所有基于对于相邻元素的查找和交换的排序算法，平均时间复杂度都至少为$O(N^2)$</p><h3 id="binary-insertion-sort">Binary Insertion Sort</h3><ol><li>总共扫描 N - 1 次</li><li>对于第 $p$ 次扫描 ( $p \in [1,N-1]$ ), 将下标为 $p$ 的元素在数组的 $[0,p-1]$ 范围内进行二分查找。当然查找该元素不会有结果，目的是确定需要插入的位置</li><li>将下标为 $p$ 的元素不断与其左侧元素交换直至到达 (2) 中确定的位置</li></ol><h2 id="bubble-sort">Bubble Sort</h2><ol><li>总共扫描 N - 1 次</li><li>对于第 $p$ 次扫描 ( $p \in [1,N-1]$ ), 扫描的范围是 $[0,-p]$</li><li>每次扫描从左至右，对于相邻的两个元素检查顺序是否正确，并进行适当调换。</li><li>扫描完成后，数列$[-p,-1]$的部分是有序的。</li></ol><p>这里数组的范围用了 Python 的表示方法，$[-i]$ 表示倒数第i个元素。</p><h2 id="shell-sort">Shell Sort</h2><ol><li>定义一个递减的“增量序列” $h_k, h_{k-1}, \ldots, h_1$, 满足递减且 $h_1=1$</li><li>总共进行 $k$ 次以下进程：<ol><li>将整个数组按增量 $h_k$ 分为 $k$ 组，组内元素下标分别满足 $0 + i_1 × h_k, 1 + i_2 × h_k, \ldots, k - 1 + i_k × h_k$.</li><li>对每一组内部的元素，在各自的位置上进行 Insertion Sort</li><li>进程结束后，每组内是有序的</li></ol></li><li>第 $k$ 次进程，即增量为 1 的进程结束后，整个数列是有序的</li></ol><h2 id="merge-sort">Merge Sort</h2><p>对于两个已经排序的序列 A &amp; B, 可以各通过一次扫描将其合成为一个有序序列。</p><ol><li>声明一个大小为 A &amp; B 大小之和的数列 S，声明两个游标分别指向 A &amp; B 的首个元素。</li><li>比较两个游标所指的元素，对较小的那个，放入 S 中，相应游标后移</li><li>某个已知数组中元素被完全放置后，按顺序将另一个已知数组的元素放入</li></ol><img src="https://s2.ax1x.com/2019/01/04/FTB3Vg.png" style="max-width: 500px !important"><p>归并排序的具体步骤：</p><ol><li>将整个数列二分，对两个子数列分别递归地调用归并排序使其有序</li><li>用前述方法将两个子数列进行单次归并得到一个有序数列并返回</li><li>递归的 base case 是数列长度为 1，此时直接返回</li></ol><h2 id="quick-sort">Quick Sort</h2><h3 id="basic-algorithm">Basic Algorithm</h3><p>对数列 X 进行排序:</p><ol><li>如果 X 中的元素个数为 0 或 1，那就直接返回</li><li>确定一个 X 中的元素 v, 称之为 pivot 基准点</li><li>将 X 中除了 v 以外的元素分为比 v 小的部分 S 和比 v 大的部分 L</li><li>对 S 和 L 递归地调用 Quick sort 使其有序，并按 S, v, L 顺序返回</li></ol><h3 id="median-of-three-partitioning">Median-of-Three Partitioning</h3><p>将一个数列的首元素、末元素和中间元素的中位数作为 pivot.</p><p>基础算法中第 2、3 步的具体实现：（注意以下的 left, right 都是左闭右闭的，即 arr[right] 也在要排序的数组中）</p><ol><li>确定是 arr[left], arr[right] 还是 arr[center] 是 pivot</li><li>将 pivot 与 arr[right] 交换</li><li>声明两个游标 i 和 j, 分别指向 arr[left] 和 arr[right-1]</li><li>循环以下过程，直到 j &lt; i 为止（j &lt; i 时不进行判断和交换）<ol><li>将 i 向右移动，直到锁定某个大于 pivot 的元素</li><li>将 j 向左移动，直到锁定某个小于 pivot 的元素</li><li>交换此时的 arr[i] &amp; arr[j]</li></ol></li><li>将 arr[i] 和现在处于 arr[right] 的 pivot 交换</li><li>交换完成后 arr[i] 是 pivot, 即 Basic Algorithm 中描述的 v, 而 S 和 L 分别是对应的左右部分</li></ol><h4 id="improving-median-of-three">Improving Median-of-Three</h4><p>在寻找 median of three 的过程中，需要进行三次判断，此时就可以直接进行交换，直接使得交换后的数列中首元素 &lt; 中间元素 &lt; 末元素。</p><p>则此时中间元素是 pivot，且已知首元素 &lt; pivot &lt; 末元素, 因此在上一段 (2) 步骤中可以改为将 pivot 与 arr[right-1] 交换。i 初始化为 left + 1, j 初始化为 right - 2.</p><h4 id="improving-small-arrays-issue">Improving Small Arrays Issue</h4><p>对于小数列，快速排序可能表现比插入排序要差。</p><p>设置某个 cutoff 值，在快速排序递归到数列长度小于 cutoff 时，转而使用插入排序。</p><p>Cutoff 通常被设置为 3.</p><h2 id="table-sort">Table Sort</h2><p>当某个数字只是一个 key, 连带还有很多其他数据，要根据这个 key 排序时，直接对所有的数据进行交换等是没有效率的。</p><p>此时建立另一个数列 T 来储存记录的顺序。在排序之前，将 T 初始化为 T[i] = i. 排序完成的结果是 data[T[i]].key 从小到大有序。</p><img src="https://s2.ax1x.com/2019/01/04/FTglSH.png"><p>排序的过程中应用前面的基础排序算法，将 arr[i] 在进行大小比较时用 data[T[i]].key 代替，交换时用 T[i] 代替。</p><p>在完成了 T 的调整，使得 data[T[i]].key 有序之后，可以高效地对所有数据本身进行物理排序。</p><p>要做到这一点，需要通过移动数据，使得数据的下标与 T “对齐”。可以证明表排序将会形成数个分离的组，各个组将会形成循环圈。按照循环圈的方向逆向转动一次就可以完成排序，如图所示。</p><img src="https://s2.ax1x.com/2019/01/04/FT20UK.png"><p>开辟一个与数据大小相同的暂存空间，利用其对每一组循环圈进行交换，最终达成“下标与 T 对齐”, 此时 key 即有序。</p><h2 id="bucket-sort">Bucket Sort</h2><p>默认数组 arr 中都是自然数。</p><ol><li>需要外部信息（或进行一遍扫描），获取数列中最大元素的大小 m</li><li>声明一个大小为 m + 1 的数组 count (可访问下标最大为 m), 并且其中元素全部初始化为 0.</li><li>扫描 arr, 将 count[arr[i]] 置为 1.</li><li>从左至右扫描 count, 将每个 count[k] == 1 的 k 输出，则输出记录就是排序完成的结果。</li></ol><p>注意如果 arr 中存在重复元素，只要将上面 (3) 修改为 count[arr[i]]++, 将 (4) 修改为将 k 输出 count[k] 次即可，这对于后面的基数排序是有重要作用的。</p><h2 id="radix-sort">Radix Sort</h2><ol><li>获取数列中最高的位数 P，总共进行 P 次桶排序</li><li>每一次桶排序中，只对于某一个数位进行排序，从右到左（从个位到高位），注意入桶和出桶时按照<s>某种玄妙的</s>顺序</li></ol><img src="https://s2.ax1x.com/2019/01/04/FTW7Bn.png" style="max-width: 450px !important;" align="middle"><p><span id="radixExp"></span></p><p>在复杂度 $O(P(N+B))$ 中，P 是最高的位数，N 是元素数量，B 是桶的数量（也就是每一位上的最大值）。</p><h2 id="external-sorting">External Sorting</h2><p>对于不能够直接读入内存的大数据，对其进行分块，在每个小区块完成排序之后通过归并排序的方式，直接在硬盘上合并成大块。最后合并的过程涉及到大量的硬盘 I/O.</p><h2 id="stability">Stability</h2><p>当一个数组中存在重复的元素时，如果一个排序算法不会交换这两个元素的位置，那就称该算法为 stable, 否则为 unstable.</p><p>Stable algorithms:</p><ul><li>Bubble</li><li>Insert</li><li>BST</li><li>Merge</li><li>Bucket</li><li>Radix</li></ul><p>Unstable algorithms:</p><ul><li>Selection</li><li>Shell</li><li>Quick</li><li>Pancake</li></ul><h1>Hashing</h1><h2 id="hash-table-and-hash-function">Hash Table and Hash Function</h2><p>哈希表是一个固定大小 TableSize 的数组，每个 key 通过哈希函数映射到 0 到 TableSize - 1 中的某个数 i ，将 key 存在 table[i] 中。</p><p>理想情况下，哈希函数需要容易计算，并且能够保证两个不同的 key 映射到的 i 不同，也就是不产生碰撞。</p><p>可能的哈希函数选择方法：</p><ul><li>如果 key 是正整数，i = mod(key, TableSize)<ul><li>TableSize 经常被设置为质数</li><li>如果 key 的分布均匀，可以得到较好的结果</li><li>可能存在 key 的分布造成结果非常差</li></ul></li><li>如果 key 是字符串<ol><li>将所有字符的 ASCII 码相加，再对 TableSize 取模</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="function">index <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">    index hashVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*key != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        hashVal += *key;</span><br><span class="line">        key++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashVal % TableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>建立一种 27 进制的方法，令 TableSize = 10007, 假设所有的字符串都有至少三位</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">index <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key[<span class="number">0</span>] + <span class="number">27</span>*key[<span class="number">1</span>] + <span class="number">729</span>*key[<span class="number">2</span>]) % TableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="collision-resolution">Collision resolution</h2><p>碰撞几乎是不可避免的，需要解决碰撞的策略。</p><h3 id="separate-chaining">Separate Chaining</h3><p>对于数列中的每一个 cell, 用一个链表来保存被哈希到这个值的所有 key.</p><p>搜索某个元素时，首先通过哈希函数找到 i ，再用遍历链表的方式遍历 arr[i] 为头节点的链表。</p><p><span id="scExp"></span></p><p>Load factor 装填因子 $\lambda$ = number of elements / TableSize = average length of lists</p><p>Ideal $\lambda$ should approach 1.</p><p>$\lambda \ll 1$ means the table is not adequately utilized.$\lambda \gg 1$ means there are too many collisions.</p><p>However, $\lambda = 1$ itself does not mean best efficiency.</p><p>Disadvantage:</p><ul><li>Allocate new cells in memory</li><li>Complex data structure</li><li>No random accessibility advantage</li></ul><h3 id="open-addressing">Open Addressing</h3><p>只能在 TableSize &gt;= Number of Elements 的时候使用。对某个将要插入的 x, 如果发生了碰撞，就对 $h_i(x) = (\operatorname{Hash}(x) + F(i)) \operatorname{mod} \text{TableSize}$, 其中 $F(0)=0$.</p><h4 id="linear-probing">Linear Probing</h4><p>$F(i)=i$. 即发生碰撞后，对其对应的哈希值 +1, +2,… 进行尝试。</p><h4 id="quadratic-probing">Quadratic Probing</h4><p>$F(i)=i^2$. 具体实现见代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(<span class="keyword">int</span> key, HashTable h)</span> </span>&#123;</span><br><span class="line">    Position current;</span><br><span class="line">    current = Hash(key, h-&gt;TableSize);</span><br><span class="line">    <span class="keyword">while</span>(h-&gt;thecells[current].info != Empty &amp;&amp; h-&gt;thecells[current].element != key)&#123;   <span class="comment">// While collisioning.</span></span><br><span class="line">        current += <span class="number">2</span>*current <span class="number">-1</span>;    <span class="comment">// Explain after the code block.</span></span><br><span class="line">        <span class="keyword">if</span>(current &gt;= h-&gt;TableSize)&#123;</span><br><span class="line">            current = current % h-&gt;TableSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> key, HashTable H)</span></span>&#123;</span><br><span class="line">    Position pos = Find(key, H);</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;thecells[pos].info != Legitimate)&#123;</span><br><span class="line">        H-&gt;thecells[pos].info = Legitimate;</span><br><span class="line">        H-&gt;thecells[pos].element = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Explaining this statement:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current += <span class="number">2</span>*current <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>$F(i) = F(i-1) + 2 \times i - 1$ for $F(i) = i^2$. 即所用的 $F(i)$ 的<strong>递推性质</strong>。</p><h4 id="double-hashing">Double Hashing</h4><p>$F(i) = i \times \operatorname{Hash}_2(x)$, where $\operatorname{Hash}_2(x)$ can be arbitrarily defined.</p><h3 id="rehashing">Rehashing</h3><p>如果目前的哈希表已经太满了，就可能导致运行的时间大大超出期望的 $O(1)$.</p><p>解决方案是建立另一张大约两倍大小的哈希表，并且将原哈希表中的所有元素存到新哈希表中。</p><h3 id="public-overflow-cache">Public Overflow Cache</h3><p>当碰撞发生时，将新元素放入另一个公共的 overflow table.</p><p>只适用于碰撞元素数量相对较小时。</p><h1>Graph Algorithms</h1><h2 id="definitions">Definitions</h2><p>A graph G = (V,E) consists of a set of vertices V and a set of edges E.</p><p>Each edge is a pair $(v, w)$, where $(v, w) \in E$, and $v, w \in V$.</p><p>If the pair is ordered, then the graph is directed, called digraph. Each edge is then denoted as $&lt;v, w&gt;$, where $&lt;v, w&gt; \in E$, and $v, w \in V$.</p><p>Vertex w is adjacent to v iff. $(v, w) \in E$ or $&lt;v, w&gt; \in E$.</p><p>Sometimes an edge can have weight, cost, distance, etc.</p><p>Path in a graph is a sequence of vertices $w_1, w_2, \ldots, w_n$, such that $(w_i, w_{i+1} \in E)$ for $1 \leq i &lt; n$. The length of the path is $n - 1$.</p><p>The edge from a vertex to itself is a loop.</p><p>A cycle in a digraph is a path of length at least 1 such that $w_1 = w_n$. A diagraph without cycles is acyclic, called DAG.</p><p>Connection:</p><ul><li>connected - in an undirected graph, if there is a path from each vertex to any other vertex.</li><li>strongly connected - in a directed graph, there is a path from each vertex to any other vertex.</li><li>weakly connected - in a non-strongly-connected directed graph, the underlying undirected graph is connected.</li></ul><p>In a digraph, for each edge $&lt;v,w&gt;$, $v$ is called the tail and $w$ is called the head.</p><ul><li>Indegree: number of edges with the vertex as head</li><li>Outdegree: number of edges with the vertex as tail</li><li>Degree: the number of edges linked to the vertex.<ul><li>Degree = Indegree + Outdegree</li><li>Number of edges = $\sum$ Indegree = $\sum$ Outdegree</li></ul></li></ul><h2 id="representation">Representation</h2><h3 id="adjacency-matrix">Adjacency Matrix</h3><p>一个方阵 matrix, 维度为 Vertex 的数量。</p><ul><li>有向图中， matrix[i][j] == 0 表示从 Vertex i 到 Vertex j 没有 Edge, 若为 1 表示有</li><li>有权重的有向图中， matrix[i][j] 表示从 Vertex i 到 Vertex j 的权重，另外 matrix[i][j] == $\infty$ 也可以表示没有 Edge</li></ul><p>Let $|V|$ represents the number of vertices and $|E|$ represents the number of edges, the space requirement is $O(|V|^2)$</p><p>If $|E|=O(|V|^2)$ then array implementation is appropriate, other wise the sparsity wastes space.</p><h3 id="adjacency-list">Adjacency List</h3><p>一个数组，数组的每个元素是一个链表，链表的头节点是数组下标对应的 Vertex, 后续的节点是这个 Vertex 的 directed edge 所指向的各个 Vertex.</p><h3 id="degrees">Degrees</h3><ul><li>Calculate the indegree of vertex x:<ul><li>Adjacenct Matrix: scan matrix[x][i]</li><li>Adjacency List: scan the whole list</li></ul></li><li>Calculate the outdegree of vertex x:<ul><li>Adjacenct Matrix: scan matrix[i][x]</li><li>Adjacency List: scan list[x] and find how many descendant nodes are there.</li></ul></li></ul><h2 id="topological-sort">Topological Sort</h2><p>Definition: an ordering of vertices in a DAG, such that if there is a path from $v_i$ to $v_j$, then $v_j$ appears after $v_i$ in the ordering.</p><p>Topological ordering is NOT possible for a digraph with cycle. The ordering is NOT necessarily unique.</p><h3 id="preliminary-implementation">Preliminary Implementation</h3><p>实现方案：</p><ol><li>如果当前的图不是空的，就找到任何 Indegree == 0 的节点 v，否则就结束</li><li>输出 v, 并且将它和所有连接着它的 edge 从图中抹去，同时更新所有节点的 Indegree</li><li>重复 (1) 和 (2) 直到没有节点为止</li></ol><h3 id="optimization-strategy">Optimization Strategy</h3><p>每次循环中，重新扫描全图并且找到 Indegree 为 0 的节点是低效的。新的符合要求的节点必然与刚刚被消除的点相邻。</p><p>利用 Queue 结构（Dequeue 后不清除记录，最终回溯整个队列获得排序）：</p><ol><li>扫描全图获得所有节点的 Indegree 并保存</li><li>Enqueue 目前所有的 0-indegree vertex</li><li>Dequeue 并获得 front, 将所有 front 连接着的 vertex 的 Indegree - 1</li><li>找到新的 0-indegree vertex, Enqueue all of them</li><li>循环直到结束</li><li>Queue 中的记录就是拓扑排序的结果</li></ol><h2 id="shortest-path-algorithms">Shortest-Path Algorithms</h2><p>两个术语：</p><ul><li>BFS - Breadth First Search 广度优先</li><li>DFS - Depth First Search 深度优先</li></ul><h3 id="unweighted-shortest-path">Unweighted Shortest Path</h3><p>思路：</p><ol><li>确定出发点 v</li><li>找到所有从 v 出发一步能够到达的点，这些点的最短路径距离为 1</li><li>将以上点作为基准，找到它们临近的点（v 除外），这些点的最短路径距离为 2</li><li>循环以上过程直到整张图被遍历</li></ol><p>这是一种 BFS, 在过程中需要保存 3 个信息：</p><ol><li>到 s 的距离，dist</li><li>到达这个点时作为基准的节点，path</li><li>这个点是否已经被探测过了，known</li></ol><p>具体实现利用 Queue：</p><ol><li>Enqueue v, 其 dist = 1, path = -1 (to mark as the entrance)</li><li>Dequeue 并且获取 front, 将所有 front 可以一步到达的，unknown 的点 Enqueue</li><li>循环以上过程直到所有点 Known</li></ol><p>输出某个节点的路径时，根据 path 的值不断回溯。</p><h3 id="dijkstra-s-algorithm-for-weighted-graph">Dijkstra’s Algorithm for Weighted Graph</h3><p>Dijkstra’s Algorithm is a typical “Greedy Strategy”.</p><p>思路：</p><ol><li>A graph $G = (V,E)$ can be divided into 2 parts, Known and Unknown</li><li>Initially, Known = {starting vertex}, $U = V -$ Known</li><li>For $v \in$ Known, the shortest path is denoted as $\operatorname{Dist}(v)$</li><li>The set of edges crossing Known and Unknown is denoted as $E’ = {&lt;v,w&gt;|v\in \operatorname{Known}, w\in \operatorname{Unknown}, &lt;v,w&gt; \in E}$</li><li>The edge $&lt;v’,w’&gt;$ that can achieve the smallest $\operatorname{Dist}(v) + \operatorname{cost}(v’,w’)$ among all pairs of $&lt;v,w&gt;$ in $E’$ is the shortest path to vertex $w’$</li><li>Update Known and Unknown</li><li>Loop until the end</li></ol><p>注意每一次循环的时候是遍历从已知部分到未知部分的所有节点对，用这对中已知节点的最短路径距离 + 两者之间的路径距离，得到未知节点从这条路到达的最短路径距离。每个未知节点在这一步中可能被包括在不同节点对中，有不同的路径距离值（通过不同的路径到达）。最终选取的是<strong>全局</strong>层面上，所有节点对给出的路径距离中最短的一个。</p><h3 id="critical-path-analysis">Critical Path Analysis</h3><h4 id="representation-v2">Representation</h4><p>In an acyclic graph, each node represents an activity and the time it takes to complete it. The edges represent dependence relationships.</p><p>The graph is known as an activity-node graph.</p><p>Activity-Node Graph can be transformed into an Event-Node Graph.</p><p>In an event-node graph, a node represents completion of an activity, whose incoming edge represents the activity.</p><p>Dummy nodes and edges are involved to ensure the right dependencies.</p><img src="https://img-blog.csdn.net/20150511211048164"><img src="https://img-blog.csdn.net/20150511211041126"><p>The edges that have 0 weight are dummy edges.</p><p>Dummy edges 之后跟着的节点都是 dummy nodes. 或者从另一个角度看，dummy nodes 可以由多个 edge 到达，而表示事件结束的 node 只能由 1 个 edge 到达。</p><h4 id="earliest-completion-time">Earliest Completion Time</h4><p>The earliest time that a completion-node can be achieved.</p><p>$EC_i$ 表示节点 i 的 earliest completion time.</p><p>计算方法：</p><ol><li>$EC_1 = 0$</li><li>$EC_w = \max(EC_v + c_{v,w})$ for all $&lt;v,w&gt; \in E$</li></ol><h4 id="latest-completion-time">Latest Completion Time</h4><p>The latest completion time that each event can finish <strong>without</strong> affecting the final earliest completion time.</p><p>$LC_i$ 表示节点 i 的 latest completion time.</p><p>计算方法：</p><ol><li>计算终点的 earlist completion time $EC_n$</li><li>$LC_v = \min(LC_w - c_{v,w})$, for all $&lt;v,w&gt;\in E$.</li></ol><p>从末尾节点进行倒推。</p><h4 id="slack-time">Slack Time</h4><p>The amount of slack time that each completion-edge can be delayed without delaying the overall completion.</p><p>计算方法：$\operatorname{Slack}&lt;v,w&gt; = LC_v - EC_v$</p><h4 id="brief-summary">Brief Summary</h4><p>通过图片来更直观地理解：</p><img src="https://s2.ax1x.com/2019/01/05/F7pzBn.png"><ul><li>第一张图表示 Earliest Completion Time</li><li>第二张图表示 Latest Completion Time</li><li>两者之间的滑动（箭头）表示可以调整的空间，也即 Slack Time</li></ul><h3 id="all-pairs-shortest-path">All-Pairs Shortest Path</h3><p>Definition: Given the non-negative directed graph, calculate the all-pairs shortest paths, from i to j for any pair &lt;i, j&gt; in V.</p><h4 id="executing-v-times-dijkstra">Executing |V| times Dijkstra</h4><p>Executing |V| times Dijkstra’s Algorithm, each of which starts from vertex 1, 2, …, |V|.</p><h4 id="simple-algorithm">Simple Algorithm</h4><p>用 Adjacency Matrix 来表示给定的图，记为$L^{(1)}$, 矩阵中的值定义如下：</p><ul><li>$L^{(1)}_{vw} = 0$ 表示 $v = w$</li><li>$L^{(1)}_{vw} = \text{cost/distance value of edge} &lt;v,w&gt;$</li><li>$L^{(1)}_{vw} = \infty$, 表示从 $v$ 到 $w$ 没有路径</li></ul><p>整体而言，$L^{(1)}_{vw}$ 表示了从 $v$ 到 $w$ 在 1 步范围内的情况。</p><p>下一步，建立矩阵 $L^{(2)}$, $L^{(2)}_{vw}$ 表示从 $v$ 到 $w$ 两步之内能够达到的最短路径。</p><p>建立的规则为：$L^{(2)}<em>{vw} = \min (L^{(1)}</em>{vw}, L^{(1)}<em>vx + L^{(1)}</em>{xw}), \forall x \in V$.</p><p>具体而言，它表示从 $v$ 到 $w$ 时以节点 $x$ 作为桥梁，检查所有可能的 $x$ 找到最短路径。同时记录中介 $x$.</p><p>递推地，建立矩阵 $L^{(k)}$, $L^{(k)}_{vw}$表示的是从 $v$ 到 $w$ 经过 k 步内的最短路径。其递推式完全同理。在记录中介节点时，如果中介节点也有它的中介节点，也一并记录。即每个位置记录路径的部分都是从 $v$ 到 $w$ 的所有中间节点。</p><p>递推过程形象地表示如下，记上述的矩阵操作为 $\otimes$：</p><img src="https://s2.ax1x.com/2019/01/05/F7a2ee.png"><p>以求 $C_{23}$ 为例，则取 $L_t$ 的 Row 2 和 $L_1$ 的 Columns 3 （注意下标是从 1 开始，为了和 PPT 一致）。对荧光笔划出的四对数，分别求和$a_{21}+b_{13}, \ldots, a_{24}+b_{43}$, 取这四个和中的最小值，即为 $C_{23}$ 的值，其余元素同理。</p><p><span id="attribute"> </span>可以证明，当 $k \geq |V| -1$ 时，$L^{(k)} = L^{(|V|-1)}$. 因此迭代计算出 $L^{(|V|-1)}$ 就可以得到最终的 all-pairs shortest path.</p><h5 id="optimizations">Optimizations</h5><h6 id="path-storage">Path Storage</h6><p>在存储路径时，不存储每个中间节点，而是只存储直接到达的中介节点。如果需要整条路径通过不断回溯获得。</p><p>具体实现：</p><ul><li>通过一个同样维度的矩阵 $\operatorname{Path}[i][j]$, 来记录上述的直接到达的中间节点。</li><li>$\operatorname{Path}[i][j] = -1$ 表示不需要中介</li><li>回溯输出时，如果 $\operatorname{Path}[i][j] \neq -1$ ，则策略如下：<ol><li>令 $\operatorname{Path}[i][j] = k$ 方便后续表示</li><li>输出 $k$</li><li>观察同一行的第 $k$ 列元素 $l$<ol><li>若 $l = -1$, 则输出结束</li><li>若 $l \neq -1$, 则说明这是更前序的一个中介，将 $k$ 更新为 $l$，重复上一级 (2) 步骤</li></ol></li><li>以上方法输出的是逆序的路径，若需要正序路径则将其反转即可</li></ol></li></ul><img src="https://s2.ax1x.com/2019/01/05/F7u8Fe.png"><h6 id="hopping-recursion">Hopping Recursion</h6><p>In order to get $L^{(2k)}$, instead of obtaining $L^{(2k-1)} \otimes L^{(1)}$, we can obtain $L^{(k)} \otimes L^{(k)}$.</p><p>This decrease the numbers of matrix $\otimes$ from $|V|$ to $\log |V|$.</p><h6 id="local-updating">Local Updating</h6><p>Instead of creating a new matrix to store the result of $\otimes$, update the value in the original matrix.</p><p>这样的话，在同一个矩阵空间内，分别得到的是 $L^{(1)}, L^{(2)}, L^{(4)}, \ldots, L<sup>{(2</sup>n)}$, 无法精确地得到每一步的值，但由于<a href="#attribute">前述</a>当 $k \geq |V| -1$ 时，$L^{(k)} = L^{(|V|-1)}$ 的性质，只需要迭代到 $2^n \geq |V|-1$ 就可以达到正确答案。</p><h4 id="floyd-warshall-alogrithm">Floyd-Warshall Alogrithm</h4><p>Definitions:</p><ul><li>$D^{(0)}_{vw}$ is the shortest path with no intermediate;</li><li>$D^{(1)}_{vw}$ is the shortest path with intermediate vertex 1;</li><li>$D^{(k)}_{vw}$ is the shortest path with intermediate vertex 1, 2, …, k;</li></ul><p>算法：$D^{(k)}<em>{vw} = \min (D^{(k-1)}</em>{vw}, D^{(k-1)}<em>{vk} + D^{(k-1)}</em>{kw})$.</p><p>理解：从 $v$ 到 $w$，以 $1,2,\ldots,k$ 为中介的最短路径，是以下两者中的最小值：</p><ul><li>$D^{(k-1)}_{vw}$, 即与 $k$ 无关，$k - 1$ 时的最短路径仍然是 $k$ 时的最短路径</li><li>从 $v$ 到 $k$ 的最短路径 + 从 $k$ 到 $w$ 的最短路径，两者分别可以以 $1,2,\ldots,k-1$ 为中介，即 $D^{(k-1)}<em>{vk}+ D^{(k-1)}</em>{kw}$</li></ul><p>初始的 $D^{(0)}$ 为原始的路径图。</p><ul><li>0 代表 $v=w$</li><li>数字代表距离</li><li>$\infty$ 代表从 $v$ 到 $w$ 没有直接路径</li></ul><p>迭代直到获得 $D^{(|V|)}_{vw}$, 这是考虑了全图的最终 all-pair shortest path.</p><p>以求 $D^{(3)}$ 为例：</p><img src="https://s2.ax1x.com/2019/01/05/F7wOGn.png"><p>深蓝色与红色的数字表示框中对应的 $d_{ij}$ 元素，浅蓝色的加号表示正常的数字相加。例如 <font color="0033cc">1</font> <font color="33ccff">+</font> <font color="ff3333">4</font> 表示的是 $d_{31} + d_{43}$, 以此类推。</p><p>最终得到的 $e_{ij}$ 是 $D^{(2)}$ 和 $D^*$ 中 $ij$ 位置元素之间较小的值。</p><p>注意因为求的是 $D^{(3)}$, 因此选择第 3 行第 3 列，下标从 1 开始。</p><p>整个算法从 $D^{(0)}$ 出发，计算到 $D^{(4)}$，也即遍历过每一行每一列结束。</p><h2 id="network-flow-problem">Network Flow Problem</h2><p>考虑一个水流系统，“水流”从 $s$ 流向 $t$. 对于一条边 $&lt;v,w&gt;$, 其权重表示这条边可以经过的最大流量。</p><p>Network Flow Problem 要解决从 $s$ 流向 $t$ 的最大流量。</p><h3 id="simple-algorithm-v2">Simple Algorithm</h3><p>对一张给定的 $G$, 画出 $G_f$ 和 $G_r$, 分别表示已经找到的流量和剩余的流量。</p><p>初始状态：</p><ul><li>两张图的节点和边的位置与原图完全相同。</li><li>$G_f$ 每条边的 value 为 0</li><li>$G_f$ 每条边的 value 与 $G$ 相同</li></ul><p>实现过程：</p><ol><li>在 $G_r$ 中找到任意一条从 $s$ 到 $t$ 的路径</li><li>找到这个路径上所有的边的 value 的最小值 $m$</li><li>将 $G_r$ 这条路径上的所有边的 value 减去 $m$, 将 $G_f$ 这条路径上的所有边的 value 加上 $m$<ul><li>注意当 $G_r$ 中有边的 value 为 0 时，就要删去这条边，不能再经过</li></ul></li><li>重复以上过程，直到 $G_r$ 中没有任何可行的从 $s$ 到 $t$ 的路径为止</li></ol><p>初始情况: (left - $G_f$, right - $G_r$)<img src="https://s2.ax1x.com/2019/04/28/EQjTCq.png"></p><p>选择完第一次路径之后的情况：<img src="https://s2.ax1x.com/2019/04/28/EQjI5n.png"></p><p>算法得到的答案<strong>不一定是正确的</strong>。</p><h3 id="modification">Modification</h3><p>在每次从 $G_r$ 这条路径上的所有边 $&lt;v,w&gt;$ 的 value 减去 $m$ 时，增加一条 value 相同的 $&lt;w,v&gt;$ （反向）的边。</p><p>这样就能保证答案的正确性。</p><p>具体的实现可以使用 Unweighted Shortest Path 算法。</p><p><span id="expMaxFlow"></span></p><p>算法的复杂度为 $O(f \times |E|)$, 其中 $f$ 为最终的最大流量结果。</p><h2 id="minimum-spanning-tree">Minimum Spanning Tree</h2><p>Consider a cost weighted graph, when asked to traverse the graph with the lowest cost, then a minimum spanning tree will be constructed.</p><p>Constructing the minimum spanning tree is to find the most cost-efficient N-1 edges to connect N verices.</p><h3 id="prim-s-algorithm">Prim’s Algorithm</h3><ul><li>将所有的节点划分为两个集合，其一是已经被包含在树内的 (A)，其二是未被包含在树内的 (B)。</li><li>遍历从 A 到 B 的所有可能路径，将其中最短的一条路径那端的节点加入树中，这条路径作为树的连接。</li></ul><p>本质与 <a href="#dijkstras-algorithm-for-weighted-graph">Dijkstra’s Algorithm</a>完全相同。</p><h3 id="kruskal-s-algorithm">Kruskal’s Algorithm</h3><p>解决方案：</p><ol><li>从全局的所有边中，依次选出选中最小的边</li><li>如果这条边不会与已有的边形成回环，就将其包括入树中。否则，将其废弃</li><li>循环，直到树中的边的数量达到 $|V|-1$ 为止</li></ol><p><em>PPT: Think about how to avoid a cycle. 以下是我参考资料后给出的想法，不保证正确性。</em></p><p>解决方案：</p><ol><li>在建立第一条边 $e_1$ 时，建立一个集合 $S_1$, 其中元素为 $e_1$ 两侧的两个节点。</li><li>之后建立每一条边 $e$ 时，对于 $e$ 两端的节点 $v,w$：<ol><li>如果 $v,w$ 都不在任意 $S_i$ 中，就新建立一个集合 $S_{n+1}$</li><li>如果 $v,w$ 中有一个在某个特定的 $S_k$ 中，另一个不在任何 $S_i$ 中，那就将这“另一个”加入 $S_k$</li><li>如果 $v,w$ 分别属于两个特定的 $S_p, S_q$, 那就合并 $S_p, S_q$</li><li>如果 $v,w$在同一个 $S_k$ 中，那么就会形成回环，这条边应当被舍弃</li></ol></li></ol><img src="https://s2.ax1x.com/2019/01/05/F7yYVK.png" width="600"><p>例如在上图中，如果下一条将要加入的边两侧的节点为：</p><ul><li>4 和 6: 合并 $S_1, S_2$</li><li>4 和 2: 同属于 $S_1$ 中，此边应当废弃</li><li>4 和 5: 将 5 加入 $S_1$ 中</li></ul><h1>Appendix: Table of Complexity of ALL algorithms</h1><table><thead><tr><th>大类</th><th>项目</th><th>Mean/Precise</th><th>Worst</th><th>Best</th></tr></thead><tbody><tr><td>斐波那契数列</td><td>递归</td><td></td><td>$O(\frac{5}{3}^N)$</td><td>$O(\frac{3}{2}^N)$</td></tr><tr><td></td><td>迭代</td><td>$O(N)$</td><td></td><td></td></tr><tr><td>最小子串和</td><td>穷举</td><td>$O(N^3)$</td><td></td><td></td></tr><tr><td></td><td>优化</td><td>$O(N^2)$</td><td></td><td></td></tr><tr><td></td><td>Divide-and-Conquer</td><td>$O(N\log N)$</td><td></td><td></td></tr><tr><td></td><td>最佳</td><td>$O(N)$</td><td></td><td></td></tr><tr><td>查找</td><td>顺序</td><td></td><td>$O(N)$</td><td></td></tr><tr><td></td><td>二分</td><td></td><td>$O(\log N)$</td><td></td></tr><tr><td>Array Lists</td><td>PrintList</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Find</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Findkth</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Insert</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Delete</td><td>$O(N)$</td><td></td><td></td></tr><tr><td>Linked Lists</td><td>PrintList</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Find</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Findkth</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Insert</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Delete</td><td>$O(1)$</td><td></td><td></td></tr><tr><td>Linked List Implementation of Stacks</td><td>IsEmpty</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>CreateStack</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>MakeEmpty</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>DisposeStack</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Push</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Top</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Pop</td><td>$O(1)$</td><td></td><td></td></tr><tr><td>Array Implementation of Stacks</td><td>IsEmpty</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>CreateStack</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>MakeEmpty</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>DisposeStack</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Push</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Top</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Pop</td><td>$O(1)$</td><td></td><td></td></tr><tr><td>Array Implementation of Queue</td><td>Enqueue</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Dequeue</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>IsEmpty</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>IsFull</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>CreateQueue</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>MakeEmpty</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>DisposeQueue</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Succ</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Front</td><td>$O(1)$</td><td></td><td></td></tr><tr><td>找到迷宫路径</td><td>Stacks</td><td></td><td>$O(N\times M)$</td><td></td></tr><tr><td></td><td>Queue</td><td></td><td>$O(N\times M)$</td><td></td></tr><tr><td>Binary Tree</td><td>四种遍历</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Height（函数）</td><td>$O(N)$</td><td></td><td></td></tr><tr><td>Binary Search Tree</td><td>MakeEmpty</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Find</td><td>Roughly $O(\log N)$</td><td>$O(N)$</td><td></td></tr><tr><td></td><td>FindMin</td><td>Roughly $O(\log N)$</td><td>$O(N)$</td><td></td></tr><tr><td></td><td>FindMax</td><td>Roughly $O(\log N)$</td><td>$O(N)$</td><td></td></tr><tr><td></td><td>Insert</td><td>Roughly $O(\log N)$</td><td>$O(N)$</td><td></td></tr><tr><td></td><td>Delete</td><td>Roughly $O(\log N)$</td><td>$O(N)$</td><td></td></tr><tr><td></td><td>Depth（层数空间复杂度）</td><td>$O(\log N)$</td><td>$O(N)$</td><td>$\left\lfloor \log N\right\rfloor$</td></tr><tr><td></td><td>Depth after $O(N^2)$ random insert/delete</td><td>$O(N^{1/2})$</td><td></td><td></td></tr><tr><td>Sorting</td><td>BST-Based Sorting (Time)</td><td>$O(N\log N)$</td><td>$O(N^2)$</td><td></td></tr><tr><td></td><td>BST-Based Sorting (Space)</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Straight Selection Sort</td><td>$O(N^2)$</td><td></td><td></td></tr><tr><td></td><td>Insertion Sort</td><td>$O(N^2)$</td><td>$O(N^2)$</td><td>$O(N)$</td></tr><tr><td></td><td>Binary Insertion Sort</td><td>$O(N^2)$</td><td>Little better than Insertion Sort</td><td>Little worse than Insertion Sort</td></tr><tr><td></td><td>Bubble Sort</td><td>$O(N^2)$</td><td>$O(N^2)$</td><td>$O(N)$</td></tr><tr><td></td><td>Shell Sort (General)</td><td>$N/A$</td><td>$N/A$</td><td>$O(N)$</td></tr><tr><td></td><td>Shell Sort (1,2,4,…,$2^k$)</td><td></td><td>$O(N^2)$</td><td></td></tr><tr><td></td><td>Shell Sort (1,3,7,…,$2^k-1$)</td><td></td><td>$O(N^{3/2})$</td><td></td></tr><tr><td></td><td>Merge Sort (Time)</td><td>$O(N\log N)$</td><td>$O(N\log N)$</td><td>$O(N\log N)$</td></tr><tr><td></td><td>Merge Sort (Space)</td><td>$O(N)$</td><td></td><td></td></tr><tr><td></td><td>Quick Sort (Time)</td><td>$O(N\log N)$</td><td><a href="#qsdetail">Detail</a></td><td>$O(N\log N)$</td></tr><tr><td></td><td>Quick Sort (Space)</td><td>$O(1)$</td><td></td><td></td></tr><tr><td></td><td>Table Sort Rearrangement</td><td>$O(N)$</td><td>$3N/2$</td><td>$N+1$</td></tr><tr><td></td><td>Bucked Sort (Time)</td><td>$O(M+N)$</td><td></td><td></td></tr><tr><td></td><td>Bucked Sort (Space)</td><td>$O(M)$</td><td></td><td></td></tr><tr><td></td><td>Radix Sort (Time) <a href="#radixExp">explanation</a></td><td>$O(P(N+B))$</td><td>$O(P(N+B))$</td><td></td></tr><tr><td></td><td>Radix Sort (Space)</td><td>$O(B \times N)$</td><td></td><td></td></tr><tr><td>Hash Table Searching</td><td>Separate Chaining <a href="#scExp">explanation</a></td><td>$1+\lambda/2$</td><td>$1+\lambda$</td><td></td></tr><tr><td>Adjacency Matrix</td><td>Indegree</td><td>$O(|V|)$</td><td></td><td></td></tr><tr><td></td><td>Outdegree</td><td>$O(|V|)$</td><td></td><td></td></tr><tr><td>Adjacency List</td><td>Indegree (one vertex)</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td></td><td>Outdegree (one vertex)</td><td>$O(|E|/|V|)$</td><td></td><td></td></tr><tr><td></td><td>InsertEdge</td><td>$O(|E|/|V|)$</td><td></td><td></td></tr><tr><td></td><td>Indegree (whole graph)</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td></td><td>Outdegree (whole graph)</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td>Topological Sort</td><td>Straight</td><td>$O(|V|^2)$</td><td></td><td></td></tr><tr><td></td><td>Optimized</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td>Critical Path Analysis</td><td>Unweighted Shortest Path</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td></td><td>Dijkstra</td><td>$O(|V|^2)$</td><td></td><td></td></tr><tr><td></td><td>Earliest Completion Time</td><td>$O(|E|+|V|)$</td><td></td><td></td></tr><tr><td>All-Pairs Shortest Path</td><td>|V| times Dijkstra</td><td>$O(|V|^3)$</td><td></td><td></td></tr><tr><td></td><td>Simple Matrix Iteration</td><td>$O(|V|^4)$</td><td></td><td></td></tr><tr><td></td><td>Optimized Matrix Iteration</td><td>$O(|V|^3 \log |V|)$</td><td></td><td></td></tr><tr><td></td><td>Floyd-Warshall</td><td>$O(|V|^3)$</td><td></td><td></td></tr><tr><td></td><td>Network Flow Problem <a href="#expMaxFlow">explanation</a></td><td></td><td>$O(f\times |E|)$</td><td></td></tr><tr><td>Minimum Spanning Tree</td><td>Prim</td><td>$O(|V|^2)$</td><td></td><td></td></tr></tbody></table><p><span id="qsdetail"> </span>Detail of the worst case efficiency of Quick Sort:</p><p>对于基础算法，理论上的最差情况是 $O(N^2)$, 但是通过 Median-of-Three 等策略，可以进行规避，实际达到 $O(N\log N)$, 考试时如果遇到，会声明具体的场景。</p><h1>List of Some Topics not Involved</h1><p>因为<s>我觉得</s>不考所以跳过的一些部分：</p><ul><li>Page Rank</li><li>B-Tree</li><li>Computational Complexity of External Merge Sorting</li><li>Pancake Sort</li><li>Text Pattern Matching<ul><li>Brute Force Algorithm</li><li>KMP Algorithm</li></ul></li><li>Social Network Analysis</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构自学报告【划去】期末整理</title>
      <link href="/2019/01/05/DSA-summary/"/>
      <url>/2019/01/05/DSA-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>For 经管学院卫强老师数据结构课程</p></blockquote><a id="more"></a><p>一些注意事项：</p><ul><li>老师的 PPT 中有很多代码是错误的。我已经尽量修改，但是仍然可能不完全准确。</li><li>文中出现的部分代码为 pseudo-code, 因为考试形式是笔试题，不用 coding, 代码主要是帮助理解。</li><li>将所有算法的复杂度总结在了 Appendix: Table of Complexity of ALL Algorithms 中，文章主体对每种算法介绍的部分不包括复杂度</li><li>部分内容是自己的理解，不保证完全准确</li><li>由于 Hexo 渲染多级 list 不正常，文章没有开头的目录。侧边栏目录，有一说一，效果不好。如果要找某个具体的项目请善用 Ctrl+F.</li><li>为了减少目录 nested 的层级，正文整体放在另一篇文章中，<a href="/2019/01/05/DSA-summary-detail/">点击阅读</a></li></ul><p>References:</p><ul><li>Course Slides of Prof. Wei</li><li><a href="https://www.cnblogs.com/cherryljr/p/6669489.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherryljr/p/6669489.html</a></li><li><a href="https://blog.csdn.net/gdut2015go/article/details/46548769" target="_blank" rel="noopener">https://blog.csdn.net/gdut2015go/article/details/46548769</a></li></ul><p>If there is any infringement/error, please <a href="mailto:liyifan945@163.com" target="_self">contact me</a>, modification or deletion will be implemented immediately.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
